/*
 * grunt-localcheck
 * https://github.com/vartu/localcheck
 *
 * Copyright (c) 2016 
 * Licensed under the MIT license.
 */

'use strict';

module.exports = function(grunt) {

  var chalk = require('chalk');

  grunt.registerMultiTask('localcheck', 'create file with hash for update.', function() {
    var options = this.options({
      separator: grunt.util.linefeed,
      backup : true,
      formatInclude : [],
      hashLength : 6
    });

    // Iterate over all specified file groups.
    var hashConfig = {},
      fileConfig = {},
      hfileConfig = {};
    this.files.forEach(function(f) {
      // Concat specified files.
      var src = f.src.filter(function(filepath) {
        // Warn on and remove invalid source files (if nonull was set).
        if (!grunt.file.exists(filepath)) {
          grunt.log.warn('Source file "' + filepath + '" not found.');
          return false;
        } else {
          return true;
        }
      }).map(function(filepath) {
        // Read file source.
        return grunt.file.read(filepath);

      }).join(grunt.util.normalizelf(options.separator));

      // Handle options.
      var crypto = require('crypto'),
        md5sum = crypto.createHash('md5'),
        temp = '',
        md5 = '';

      md5sum.update(src);
      md5 = md5sum.digest('hex');
      if(options.hashLength>0){
        md5 = md5.substr(0, options.hashLength);
      }

      var filename = f.orig.getConfigKey ? f.orig.getConfigKey.call(f.orig, f.src[0], f.dest) : f.src[0];

      var tempHash = hashConfig[f.orig.hashConfigName] = hashConfig[f.orig.hashConfigName] || {},
        tempFile = fileConfig[f.orig.hashConfigName] = fileConfig[f.orig.hashConfigName] || {};

      tempHash[filename] = md5;
      tempFile[filename] = {
        md5 : md5,
        src : f.src[0]
      };

      hfileConfig[f.orig.hashConfigName] = {
        config : f.orig,
        hashs : tempHash,
        files : tempFile
      };
    });

    for(var key in hfileConfig){
      if(hfileConfig.hasOwnProperty(key)){
        replaceFile(hfileConfig[key].config, hfileConfig[key].hashs, hfileConfig[key].files);
      }
    }
    
    if(typeof options.formatInclude=='string'){
      options.formatInclude = [options.formatInclude];
    }
    //format include
    checkInclude(options.formatInclude);
  });

  function checkInclude(files){
    if(typeof files=='string'){
      files = [files];
    }

    var src, incMatchs, fileMatchs,
      flag = 'localinclude',
      incReg = new RegExp('/\\*<'+flag+'.*?>\\*/[\\s\\S]*?/\\*</'+flag+'>\\*/', 'g'),
      fileReg = new RegExp('file\\s*=\\s*[\'"]?(.*?)[\'"]');

    files.forEach(function(file){
      if (!grunt.file.exists(file)) {
        grunt.log.warn('File "' + chalk.red(file) + '" not found.');
        return true;
      }

      src = grunt.file.read(file);
      while((incMatchs = incReg.exec(src)) !== null){
        if(!incMatchs){
          continue;
        }

        var pathindex = file.lastIndexOf('/'),
          path, tsrc, tfile, rfile;
        if(pathindex>-1){
          path = file.substr(0, pathindex)+'/';
        }

        incMatchs.forEach(function(clustr){
          fileMatchs = fileReg.exec(clustr);
          if(!fileMatchs){
            grunt.log.warn('Content "' + clustr + '" not found "file=" attribute.');
            return true;
          }

          rfile = fileMatchs[1].replace(/[\s]+/, '');
          tfile = path+rfile;
          if(!grunt.file.exists(tfile)){
            grunt.log.warn('Include file "' + chalk.cyan(rfile) + '" not found.');
            return false;
          }
          
          tsrc = grunt.file.read(tfile);
          src = src.replace(clustr, '/*<'+flag+' file="'+fileMatchs[1]+'">*/\r'+tsrc+'\r/*</'+flag+'>*/');
          grunt.file.write(file, src);
          grunt.log.writeln('File "' + chalk.cyan(file) + '" include "' + chalk.cyan(rfile) + '" success.');
        });
      }
    });
  }

  function replaceFile(config, jcontent, filesInfo){
    var strcontent, src, match, oldConf = {},
      flag = 'localcheck',
      configname = config.hashConfigName || 'gFileHashConfig',
      reg = new RegExp('\/\\*<'+flag+'\\s*id\\s*=\\s*[\'"]?'+configname+'[\'"]?\\s*>\\*\/([\\s\\S]*?)\/\\*<\/'+flag+'>\\*\/'),
      configfile = config.hashConfigDestFile;

    if(!configfile){
      return ;
    }

    if (!grunt.file.exists(configfile)) {
      return grunt.log.warn('File "' + chalk.red(configfile) + '" not found.');
    }

    strcontent = JSON.stringify(jcontent);

    src = grunt.file.read(configfile);
    if(config.backup){
      grunt.file.write(configfile+'.bak', src);
    }

    strcontent = '/*<'+flag+' id="'+configname+'">*/\rvar '+configname+'='+strcontent+';\r/*</'+flag+'>*/';

    //if not first append hashConfig; replace it
    match = reg.exec(src);
    if(match){
      src = src.replace(reg, strcontent);
      oldConf = (new Function(match[1]+'; var '+configname+'; return '+configname+'; ')()) || [];
    //if set hashConfigBlock
    }else{
      grunt.log.writeln('U can set hashconfig to <'+flag+' id="'+configname+'"></'+flag+'>"!');
      var scripthtml = '<script type="text/javascript">'+strcontent+'</script>\n',
        index = src.indexOf('</head>');
      index = index<0 ? 0 : index;
      src = src.substr(0, index)+scripthtml+src.substr(index);
    }

    for(var k in filesInfo){
      if(!filesInfo.hasOwnProperty(k)){
        continue;
      }

      if(filesInfo[k].md5 != oldConf[k]){
        grunt.log.writeln(chalk.magenta('[Update]') + ' file "' + chalk.cyan(filesInfo[k].src) + '" hash:'+filesInfo[k].md5+'.');
      }
    }

    grunt.file.write(configfile, src);
    grunt.log.writeln('File "' + chalk.cyan(configfile) + '" update hashConfig['+configname+'] success.');
  }

};
